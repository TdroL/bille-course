<!doctype html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">

  <title>Bille-Course - Podstawy JavaScript</title>

  <link rel="stylesheet" href="css/reveal.css">
  <link rel="stylesheet" href="css/theme/black.css">

  <!-- Theme used for syntax highlighting of code -->
  <link rel="stylesheet" href="lib/css/zenburn.css">
  <link rel="stylesheet" href="lib/css/eval.css">
</head>
<body>
  <div class="reveal">
    <div class="slides">
      <section id="start">
        <ol>
          <li><a href="#/knowledge-start">Źródła wiedzy</a></li>
          <li><a href="#/types-start">Typy danych</a></li>
          <li><a href="#/syntax-start">Syntax</a></li>
          <li><a href="#/tables-start">Tablice</a></li>
          <li><a href="#/objects-start">Obiekty</a></li>
          <li><a href="#/functions-start">Funkcje</a></li>
          <li><a href="#/hoisting-start">Hoisting</a></li>
        </ol>

        <aside class="notes"><p></p></aside>
      </section>

      <section id="knowledge-start">
        <h3>Źródła wiedzy</h3>

        <ul>
        <li><a href="https://developer.mozilla.org/">MDN Web Docs</a></li>
          <li><a href="https://caniuse.com/">Can I Use</a></li>
          <li><a href="https://stackoverflow.com/">stackoverflow</a></li>
        </ul>

        <aside class="notes"><p>o historii JavaScriptu: powstał w dwa tygodnie. Koniec</p></aside>
      </section>

      <section id="types-start">
        <h3>Typy danych</h3>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <div class="grid grid-2">
          <div>
            <p>Proste</p>
            <ul>
              <li>null</li>
              <li>undefined</li>
              <li>number</li>
              <li>string</li>
              <li>boolean</li>
            </ul>
          </div>
          <div>
            <p>Złożone</p>
            <ul>
              <li>object</li>
              <li>array</li>
              <li>function</li>
              <li>symbol</li>
            </ul>
          </div>
        </div>

        <aside class="notes"><p>proste - kopie przez wartość, złożone - kopie przez referencje</p><p>string jest prawdopodobnie kopiowany</p></aside>
      </section>

      <section>
        <img src="css/null-undefined.png" alt="null !== undefined">

        <aside class="notes"><p>obowiązkowy mem</p></aside>
      </section>

      <section>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = null; a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = undefined; a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = 1.5; a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = 'string'; a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = false; a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = { a: 1, b: 2 }; a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [1, 2, 3]; a;
        </textarea>

        <aside class="notes"><p>słowo o wbudowanej konsoli</p></aside>
      </section>

      <section>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = function () { return 0; }; a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = function named() { return 0; }; a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = () => { return 0; }; a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = () => 0; a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = function* () { yield 1; }; a;
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = Symbol.iterator; a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = Symbol('moj symbol'); a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = Symbol('foo');
let b = Symbol('foo');
a !== b;
        </textarea>

        <aside class="notes"><p>symbole sa unikalne</p><p>kilka jest predefiniowanych</p></aside>
      </section>

      <section>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = Symbol.for('moj symbol'); a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = Symbol.for('foo');
let b = Symbol.for('foo');
a === b;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = Symbol('foo');
let b = Symbol.for('foo');
a !== b;
        </textarea>

        <aside class="notes"><p>Symbol.for() posiada globalny zbiór, Symbol(wartość) nie doda do tego mappingu</p></aside>
      </section>

      <section>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
typeof undefined;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
typeof null;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
typeof 1.5;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
typeof 'string';
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
typeof false;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
typeof { a: 1, b: 2 };
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
typeof [1, 2, 3];
        </textarea>

        <aside class="notes"><p>operator typeof</p><p>null, undefined i array zachowują się nietypowo</p><p>null - brak obiektu, undefiend - brak wartości</p></aside>
      </section>

      <section>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
typeof function () { return 0; };
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
typeof function named() { return 0; };
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
typeof (() => { return 0; });
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
typeof (() => 0);
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
typeof function* () { yield 1; };
        </textarea>

        <aside class="notes"><p>funkcje zachowują się w oczekiwany sposób</p></aside>
      </section>

      <section>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
typeof Symbol.for('foo');
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section id="syntax-start">
        <h3>Syntax</h3>

        <h4>Deklarowanie zmiennych</h4>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <textarea class="eval" data-no-strict autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
a = 1;
a;
        </textarea>

        <textarea class="eval" data-no-strict autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
"use strict";
a = 1;
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
window.a = 1; // `global.a = 1;` w Node.js
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
var a = 1;
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = 1;
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
const a = 1;
a;
        </textarea>

        <aside class="notes"><p>słowo o background w wpaski - tryb non-strict</p><p>włączamy ten tryb na poziomie scope'a</p><p>`window.a` w node jako `global.a`</p><p>var/let/const wytłumaczony będzie za chwile</p></aside>
      </section>

      <section>
        <textarea class="eval" data-no-strict autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
a = 1; a = 2;
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
window.a = 1; window.a = 2;
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
var a = 1; var a = 2;
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = 1; let a = 2;
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
const a = 1; const a = 2;
a;
        </textarea>

        <aside class="notes"><p>redeklaracja zmiennej</p></aside>
      </section>

      <section>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
var a = 1;
a = 2;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = 1;
a = 2;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
const a = 1
a = 2;
        </textarea>

        <aside class="notes"><p>nadpisywanie zmiennej</p></aside>
      </section>

      <section id="syntax-operators-start">
        <h3>Syntax</h3>

        <h4>Operatory</h4>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <h4>Logiczne</h4>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
false || true;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
false && true;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
0 || 4;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
2 && 4;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
!2;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
!!0 // !(!0);
        </textarea>

        <aside class="notes"><p>operatory `&&` i `||` nie rzutują na booleana, tylko zwracają prawdziwie-podobną wartość</p><p>`!` rzutuje na booleana</p><p>rzutowanie na booleana można wymusić przez podwójną negację</p></aside>
      </section>

      <!-- <section>
        <h4>Logiczne #2</h4>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = { /*prop: 'pierwotna wartość' */ };
let b = a.prop || 'domyślna wartość';
b;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = {};
let b = a.b && a.b.c && a.b.c.d && a.b.c.d[0];
b;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = {};
let b = a.b.c.d[0];
b;
        </textarea>

        <aside class="notes"><p>znak `===` porównuje też typy watrości</p><p>jeżeli `==` zwróci true, to nie znaczy, że `===` zwróci true</p><p>jeżeli `!=` zwróci true, to nie znaczy, że `!==` zwróci true</p></aside>
      </section> -->

      <section>
        <h4>Porównania słabe a mocne</h4>
        <small>== vs ===</small>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
1 == 1;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
1 == '1';
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
1 === 1;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
1 !== '1';
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <p>Porównania a fałszywo-podobne wartości #1</p>
        <small>falsy values</small>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
null == undefined;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
null !== undefined;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
null != false;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
undefined != false;
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <p>Porównania a fałszywo-podobne wartości #2</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
'' == false;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
'' !== false;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
0 == false;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
0 !== false;
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <p>Fałszywo-podobne wartości a negacja</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
!null;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
!undefined;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
!false;
        </textarea>

        <aside class="notes"><p>operacje matematyczne typu number i string mogą zwrócić NaN</p><p>wyjątek to dodawanie</p></aside>
      </section>

      <section>
        <p>Porównania z NaN</p>
        <small>not a number</small>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
NaN != NaN;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
NaN !== NaN;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
isNaN(NaN);
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
isNaN(1/'a');
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
1/'a' != NaN;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
isNaN(0/0);
        </textarea>

        <aside class="notes"><p>pusty string jest interpretowany jako 0</p></aside>
      </section>

      <section>
        <p>Porównania z infinity</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
Infinity === Infinity;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
-Infinity !== Infinity;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
1/0 === Infinity;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
-1/0 === -Infinity;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
1/'' === Infinity;
        </textarea>

        <aside class="notes"><p>IEEE 754</p></aside>
      </section>

      <section>
        <h4>Matematyczne</h4>
        <ul>
          <li>
            a * b, a / b, a + b, a - b, a % b
          <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
0.1 + 0.2;
        </textarea>
          </li>
          <li>
            ** (ES7)
          <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
2 ** 4; // Math.pow(2, 4);
        </textarea>
          </li>
        </ul>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <h4>Rzutowania (koercja)</h4>
        <ul>
          <li>
            Na liczby: +a
            <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
+'2';
            </textarea>
          </li>
          <li>
            Na "undefined": void a
            <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
void 0;
            </textarea>
          </li>
          <li>
            Na string: ''+a
            <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
''+true;
            </textarea>
          </li>
        </ul>

        <aside class="notes"><p>zawsze trzeba escapować backslash</p></aside>
      </section>

      <section>
        <h4>Tworzenie stringów</h4>
        <ul>
          <li>
            Przez pojedyńczy cudzysłów
            <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
'text "quote" O\'hara ` \\ \n';
            </textarea>
          </li>
          <li>
            Przez podwójny cudzysłów
            <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
"text \"quote\" O'hara ` \\ \n";
            </textarea>
          </li>
          <li>
            Przez backtick
            <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
`text "quote" O'hara \` \\ \n`;
            </textarea>
          </li>
        </ul>


        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <h4>Złączenia stringów</h4>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
'1' + 1;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
1 + '1';
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
'1' + 2 + 3;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
1 + 2 + '3';
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
'a=' + 1 + ' b=' + true + ' c=' + null;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
'a=' + [1, 2, 3];
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
'a=' + { a: 1, b: 2, c: 3 };
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = "text";
let b = 1;
`${a} ${b + 2} ${new Date().getFullYear()}`;
        </textarea>

        <aside class="notes"><p>rzutują na integera</p></aside>
      </section>

      <section>
        <h4>Bitowe</h4>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
1 | 2;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
1 & 2;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
3 ^ 4;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
~4 // == -Math.floor(4) - 1;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
1 &lt;&lt; 2;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
4 &gt;&gt; 1;
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <h4>Shorthands</h4>
        <ul>
          <li>||=, &&=, !=</li>
          <li>*=, /=, +=, -=, %=, **= (ES7)</li>
          <li>|=, &=, ^=, &lt;&lt;=, &gt;&gt;=</li>
        </ul>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <h4>Przecinek</h4>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
1, 2;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = (1, 2);
a;
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <p>Zastosowania</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let arg = 'treść'; // null, false, 0, '', undefined
let param = arg || 'domyślna';
param;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let arg = { b: { c: [1] } };
let param = arg.b && arg.b.c && arg.b.c[0];
param;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let arg = 1.91268313;
let param = arg | 0; // bitowy "or"
param;
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section id="syntax-loops-start">
        <h3>Syntax</h3>

        <h4>Pętle</h4>

        <aside class="notes"><p>skupimy się na for...in i for...of</p></aside>
      </section>

      <section>
        <ul>
          <li>for</li>
          <li>do...while</li>
          <li>while</li>
          <li>for...in</li>
          <li>for...of</li>
        </ul>

        <aside class="notes"><p>for...in na obiekcie zwraca klucze</p></aside>
      </section>

      <section>
        <p>for...in na obiektach</p>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let value = { a: 1, b: 2, c: 3 };
for (let x in value) {
  log(x, value[x]);
}
        </textarea>

        <aside class="notes"><p>for...in na obiekcie zwraca indeksy jako stringi</p><p>lepiej użyc zwykłego for</p></aside>
      </section>

      <section>
        <p>for...in na tablicach</p>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let value = [1, 2, 3];
for (let x in value) {
  log(x, value[x]);
}
        </textarea>

        <aside class="notes"><p>skoro array jest obiektem, to for...in też będzie iterował po dodanych kluczach</p></aside>
      </section>

      <section>
        <p>for...in i zmodyfikowana tablica</p>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let value = [1, 2, 3];
value.prop = 4;
for (let x in value) {
  log(x, value[x]);
}
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <p>for...of na tablicach</p>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
for (let x of [1, 2, 3]) {
  log(x);
}
        </textarea>

        <aside class="notes"><p>o tym jak się iterować po obiektach będzie później (slajd 66)</p></aside>
      </section>

      <section>
        <p>for...of na nieiterowalnych obiektach</p>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
for (let x of { a: 1, b: 2, c: 3 }) {
  log(x);
}
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <p>for...of na iterowalnych obiektach</p>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
const values = new Map();
values.set("a", 1);
values.set("b", 2);
values.set("c", 3);

for (let x of values) {
  log(x);
}
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section id="tables-start">
        <h3>Tablice</h3>

        <aside class="notes"><p>rekomendowane []</p></aside>
      </section>

      <section>
        <p>Inicjalizacja</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [];
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = new Array();
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = Array();
a;
        </textarea>

        <aside class="notes"><p>rekomendowane Array(number)</p></aside>
      </section>

      <section>
        <p>Inicjalizacja z długością</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [];
a.length = 5;
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [];
a[4] = 'b';
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = new Array(5);
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = Array(5);
a;
        </textarea>

        <aside class="notes"><p>puste wartości na konsolach mogą być reprezentowane różnie</p><p>krótko opisać array.map()</p></aside>
      </section>

      <section>
        <p>Puste wartości</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [];
a[0] = 'a';
a[4] = 'b';
a.map((value, index) => {
  log(index, a[index]);
  return true;
});
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = Array(5).map(() => {
  log('hello?');
  return true;
});
a;
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [];
a[4] = 'b';
a.fill(null).map(() => true);
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = Array(5).fill(null).map(() => true);
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [...Array(5)].map(() => true);
a;
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <p>Referencje i płytkie kopie</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [];
let b = a;
a === b;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [];
let b = [];
a !== b;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [];
a !== [];
        </textarea>

        <aside class="notes"><p>tablice sa kopiowane przez referencje</p><p>1. przykład a i b modyfikują tę samą tablice, w 2. modyfikują osobne</p></aside>
      </section>

      <section>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [];
let b = a;
a[0] = 1;
b[1] = 2;
log('a', a);
log('b', b);
a === b;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [];
let b = [];
a[0] = 1;
b[1] = 2;
log('a', a);
log('b', b);
a !== b;
        </textarea>

        <aside class="notes"><p>kopiowanie tablicy, o spreadzie będzie za dwa slajdy</p></aside>
      </section>

      <section>
        <h4>Płytkie kopiowanie tablicy</h4>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [1];
let b = a.slice();
a !== b;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [1];
let b = [].concat(a);
a !== b;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [1];
let b = [...a];
a !== b;
        </textarea>

        <aside class="notes"><p>tablice wewnątrz tablicy są nadal kopiowane prezez referencje</p></aside>
      </section>

      <section>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [[1], [2, 3]];
let b = a.slice();
a[0] === b[0]
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [[1], [2, 3]];
let b = [...a];
a[0] === b[0]
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <p>Operator spread</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [1, 2, 3];
let b = [0, ...a, 4, 5];
b;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [0, ...[1, 2, 3], 4, 5];
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
function fn () { return [1, 2, 3]; }
let a = [0, ...fn()];
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [...[], 0, ...(true ? [1, 2, 3] : [])];
a;
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <p>Operator spread a wartości <u>nie</u>iterowalne</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = null;
let b = [...a];
b;
        </textarea>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = undefined;
let b = [...a];
b;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = {};
let b = [...a];
b;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = true;
let b = [...a];
b;
        </textarea>

        <aside class="notes"><p>wartości iterowalne można przemienić na tablice przez funkcje Array.from()</p></aside>
      </section>

      <section>
        <p>Operator spread a wartości iterowalne</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = new Map();
a.set("a", 1);
a.set("b", 2);
let b = [...a];
b;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = new Map();
a.set("a", 1);
a.set("b", 2);
let b = Array.from(a);
b;
        </textarea>

        <aside class="notes"><p>wartości iterowalne i spread można wykorzystać w wywoływaniu funkcji</p></aside>
      </section>

      <section>
        <p>Spread i argumenty funkcji</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let fn = (a, b, c, d) => {
  log(a, b, c, d);
  return a + b + c + d;
};
let a = [2, 3];
fn(1, ...a, 4);
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <p>Dodawanie elementów</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [2, 3];
a = [...a, 1];
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [2, 3];
a.push(1);
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [2, 3];
a = [1, ...a];
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [2, 3];
a.unshift(1);
a;
        </textarea>

        <aside class="notes"><p>splice: `2` - indeks początkowy, `1` - ilosc elementów (opcjonalne, domyślnie `a.length`)</p></aside>
      </section>

      <section>
        <p>Usuwanie elementów</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [1, 2, 3, 4, 5];
delete a[2];
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [1, 2, 3, 4, 5];
log(a.splice(2, 1)); // zwraca elementy usunięte
a;
        </textarea>

        <aside class="notes"><p>filter: callback dostaje 3 argumenty</p><p>slice: `0` i `3` - indeks początkowy, `2` - ilosc elementów (opcjonalne, domyślnie `a.length`)</p></aside>
      </section>

      <section>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [1, 2, 3, 4, 5];
let b = a.filter((_, i) => i !== 2);
b;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [1, 2, 3, 4, 5];
let b = [...a.slice(0, 2), ...a.slice(3)];
b;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [1, 2, 3, 4, 5];
let b = [...a];
b.splice(2, 1);
b;
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <p>Czyszczenie tablicy</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [1, 2, 3, 4, 5];
a = [];
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [1, 2, 3, 4, 5];
a.splice(0);
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = [1, 2, 3, 4, 5];
a.length = 0;
a;
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section id="objects-start">
        <h3>Obiekty</h3>
        <small>plain old data</small>

        <aside class="notes"><p>klucze staja sie stringami</p></aside>
      </section>

      <section>
        <p>Tworzenie</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = {};
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = { a: 1 };
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = { 0: 1 };
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = { true: 1 };
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = { null: 1 };
a;
        </textarea>

        <aside class="notes"><p>ignoruj tryb non-strict</p><p>parsowanie bloku ma priorytet przed tworzeniem obiektu</p></aside>
      </section>

      <section>
        <p>gotchas!</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
[]
        </textarea>

        <textarea class="eval" data-no-strict autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
{}
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
{ a: 1 }
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
{ a: 1, b: 2 }
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
({ a: 1, b: 2 })
        </textarea>

        <aside class="notes"><p>nawiasy kwadratowe pozwalaja na obilczenie wartosci klucza</p><p>wynik musi być stringiem, inaczej jest rzutowany</p></aside>
      </section>

      <section>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = { [true]: 1 }
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = { [null]: 1 }
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let arr = [1, 2, 'a'];
let a = { [arr]: 1 }
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = { [{ b: 2 }]: 1 }
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = { ['timestamp-' + Date.now()]: 1 }
a;
        </textarea>

        <aside class="notes"><p>klucze zdefiniowane później nadpisują te wcześniejsze</p><p>trzeba uważać przy zwracanych wynikach, lub to mądrze wykorzystać</p><p>array'e sa joinowane</p><p>obiekty castowane do '[object Object]'</p><p>uwaga na funkcje, których wynik się zmienia</p></aside>
      </section>

      <section>
        <p>Dostęp</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = { [true]: 1, 'true': 2 };
a.true;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = { [null]: 1, 'null': 2 };
a.null;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let arr = [1, 2, 'a'];
let a = { [arr]: 1, '1,2,a': 2 };
a[[1, 2, 'a']] // a['1,2,a']
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = { [{ b: 2 }]: 1, [{ c: 3 }]: 2 };
a[{ b: 2 }] // a['[object Object]']
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = { ['timestamp-' + Math.random()]: 1 };
a['timestamp-' + Math.random()]
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <p>Przypisywanie</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = {};
a.propA = 1
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = {};
a['propA'] = 1;
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let arr = [1, 2, 'a'];
let a = {};
a[arr] = 1;
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = {};
a[{ b: 2 }] = 1;
a;
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <p>Destrukturyzacja i operator rest</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let obj = { a: 1, b: 2, c: "3", d: [4] };
let { a, d } = obj;
log("a", a);
log("d", d);
obj;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let obj = { a: 1, b: 2, c: "3", d: [4] };
let { a, d, ...rest } = obj;
log("a", a);
log("d", d);
log("rest", rest);
obj;
        </textarea>

        <aside class="notes"><p>destrukturyzacja nie modyfikuje obiektu źródłowego</p></aside>
      </section>

      <section>
        <p>Pętle na obiektach</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let obj = { a: 1, b: 2 };
for (let key in obj) {
  log(key, obj[key]);
}
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
for (let value of { a: 1, b: 2 }) {}
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let obj = { a: 1, b: 2 };
for (let key of Object.keys(obj)) {
  log(key, obj[key]);
}
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let obj = { a: 1, b: 2 };
for (let pair of Object.entries(obj)) {
  log(pair);
}
        </textarea>

        <aside class="notes"><p>1. for...in</p><p>2. for...of</p></aside>
      </section>

      <section>
        <p>Klucze i wartości</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let obj = { a: 1, b: 2 };
Object.keys(obj);
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let obj = { a: 1, b: 2 };
Object.entries(obj);
        </textarea>

        <aside class="notes"><p>co zwracją Object.keys() i Object.entries()</p></aside>
      </section>

      <section>
        <p>Usuwanie kluczy</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = { a: 1, b: 2, c: 3 };
delete a.c;
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = { a: 1, b: 2, c: 3 };
let { c, ...b } = a;
b;
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <p>Kopiowanie</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = { a: 1 };
let b = a; b.a = 2;
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = { a: 1 };
let b = { ...a }; b.a = 2;
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = { a: 1 };
let b = Object.assign({}, a);
b;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = { a: 1 };
let b = Object.create(a);
b; // b.a
        </textarea>

        <aside class="notes"><p>tak jak tablice, obiekty są kopiowane przez referencje</p><p>do wykonania płytkiej kopii potrzeba albo spread/rest, albo Object.assign()</p><p>Object.create() tworzy nowy obiekt na podstawie źródłowego, przez co wsolne property będzie się tam znajdowało</p></aside>
      </section>

      <section id="functions-start">
        <h3>Funkcje</h3>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
function fn() { return 1; }
fn();
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let fn = function () { return 1; };
fn();
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let fn = () => { return 1; };
fn();
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let fn = () => 1;
fn();
        </textarea>

        <aside class="notes"><p>różnica między function a arrow function będzie dopiero pokazana przy obiektowości</p></aside>
      </section>

      <section>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
function fn(a, b = 2) { return [a, b]; }
fn(1);
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
function fn(a = 1, b = 2) { return [a, b]; }
fn(undefined, 1);
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
function fn(a = 1, b = 2) { return [a, b]; }
fn(null, 1);
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
function fn(a = 1, b) { return [a, b]; }
fn(undefined, 1);
        </textarea>

        <aside class="notes"><p>domyślne wartości nie muszą być na końcu listy argumentów</p><p>undefined pozwoli na defaultową wartość, ale null nie</p></aside>
      </section>

      <section id="hoisting-start">
        <h3>Hoisting i scope</h3>
        <p>var, let, const</p>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <small><i>var</i> - what you wrote</small>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
if (true) {
  var a = 1;
}
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
log(a);
if (true) {
  var a = 1;
}
a;
        </textarea>

        <aside class="notes"><p>var - scope funkcyjny</p><p>co to hoisting</p></aside>
      </section>

      <section>
        <small>what's actually going on</small>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
var a;
if (true) {
  a = 1;
}
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
var a;
log(a);
if (true) {
  a = 1;
}
a;
        </textarea>

        <aside class="notes"><p>co się tak na prawdę stało na poprzednim slajdzie</p></aside>
      </section>

      <section>
        <small><i>let</i> - better at everything</small>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let a = { value: 1 };
if (true) {
  let a = 1;
  log('a', a);
}
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
log(a);
let a = 1;
        </textarea>

        <aside class="notes"><p>let - scope blokowy</p><p>shadowing</p><p>brak hoistingu</p></aside>
      </section>

      <section>
        <small><i>const</i> - the same!</small>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
const a = { value: 1 };
if (true) {
  const a = 1;
  log('a', a);
}
a;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
log(a);
const a = 1;
        </textarea>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <small>hoisting funkcji</small>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
function fn() { return 1; }
log(fn);
log(fn());
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
log(fn);
log(fn());
function fn() { return 1; }
        </textarea>

        <aside class="notes"><p>hoisting nazwanych funkcji - najbardziej przydatne</p></aside>
      </section>

      <section>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
var fn = function() { return 1; }
log(fn);
log(fn());
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
log(fn);
log(fn());
var fn = function() { return 1; }
        </textarea>

        <aside class="notes"><p>hoisting funkcji przypisanych do zmiennych już tak dobrze nie działa</p><p>o ile deklaracja `var` jest hoistowana, to przypisanie funkcji już nie</p></aside>
      </section>

      <section>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
let fn = function() { return 1; }
log(fn);
log(fn());
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
log(fn);
log(fn());
let fn = function() { return 1; }
        </textarea>

        <aside class="notes"><p>let przy hoistingu przypisania funkcji nie pomoże</p></aside>
      </section>

      <section>
        <p>var i scope funkcyjny</p>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
function fn() {
  var a = 1;
  return a;
}
log('fn()', fn());
log('a', a);
        </textarea>

        <aside class="notes"><p>var - scope fukncyjny</p></aside>
      </section>

      <section>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
var a = { value: 1 };
function fn() {
  var a = 1;
  return a;
}
log('fn()', fn());
log('a', a);
        </textarea>

        <aside class="notes"><p>var - scope fukncyjny</p><p>shadowing - oba `a` to dwie różne zmienne</p></aside>
      </section>

      <section>
        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
for (var i = 0; i &lt; 2; i++) {
  log(i);
}
i;
        </textarea>

        <textarea class="eval" autocomplete="off" autocorrect="off" spellcheck="false" rows="1">
for (let i = 0; i &lt; 2; i++) {
  log(i);
}
i;
        </textarea>

        <aside class="notes"><p>na koniec: hoisting var jest łatwy do przeoczenia w pętlach for</p><p>let temu zapobiega</p></aside>
      </section>

      <section>
        <h3>;</h3>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <a href="https://www.reddit.com/r/ProgrammerHumor/comments/8srix1/thanks_brendan_for_giving_us_the_javascript/">
          <img src="css/thanks-brendan-for-giving-us-the-javascript.png" alt="Thanks Brendan for giving us the Javascript">
        </a>

        <aside class="notes"><p></p></aside>
      </section>

      <section>
        <img src="css/javascript-was-a-mistake.jpg" alt="Javascript was a mistake">

        <aside class="notes"><p></p></aside>
      </section>

    </div>
  </div>

  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.js"></script>

  <script>
    Reveal.initialize({
      dependencies: [
        { src: 'plugin/eval/eval.js' },
        { src: 'plugin/notes/notes.js' },
      ],
      history: true,
      slideNumber: true,
      // center: false,
    });
  </script>
</body>
</html>
